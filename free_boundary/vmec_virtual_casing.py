import numpy as np
from simsopt.mhd import vmec_compute_geometry
# from simsopt.geo import SurfaceRZFourier

class VirtualCasingField:
    """
    Class to compute B_external from a vmec equilibria by using the virtual casing principle.
    """

    def __init__(self, vmec, biotsavart, s=1.0, ntheta=256, nphi=1024):
        """Initialize a VirtualCasingField object.

        Args:
            vmec (Vmec): A Vmec object
            biotsavart (BiotSavart): A BiotSavart object to compute the Biot-Savart field from coils.
            s (float, optional): Normalized toroidal flux coordinate on which to perform the VC integral. Defaults to 1.
            ntheta (int, optional): number of theta quadpoints. Defaults to 256.
            nphi (int, optional): number of phi quadpoints. Defaults to 1024.
        """
        self.vmec = vmec
        self.s = s
        self.ntheta = ntheta
        self.nphi = nphi
        self.biotsavart = biotsavart

        vmec.run()

        self.data = vmec_compute_B(vmec, s=s, theta=np.linspace(0, 2*np.pi, ntheta, endpoint=False),
                                    phi=np.linspace(0, 2*np.pi, nphi, endpoint=False))
        Bx = self.data.B_X[0].T # (nphi, ntheta)
        By = self.data.B_Y[0].T
        Bz = self.data.B_Z[0].T
        self.B_boundary = np.stack([Bx, By, Bz], axis=-1) # (nphi, ntheta, 3)

    def set_points(self, xyz_target):
        """Set the target points at which B_external will be computed.

        Args:
            xyz_target (array): (n, 3) array of points NOT on the plasma boundary (s=1).
        """
        self.xyz_target = xyz_target
        self.biotsavart.set_points(xyz_target)

    def B(self):
        """Compute the total field outside of the plasma boundary, 
            B = B_P + B_biotsavart.
        where B_P is the field generated by the plasma currents. By the virtual casing principle,
        outside the plasma boundary, B_P = - B_external.

        Prior to calling this method, set_points(xyz_target) must be called.

        Returns:
            array: (n, 3) array of B(xyz_target).
        """
        B_bs = self.biotsavart.B()
        B_ext = self.B_external(self.xyz_target)
        return B_bs - B_ext

    def dB_by_dX(self):
        """Compute the gradient tensor total field outside of the plasma boundary, 
            grad(B) = grad(B_P) + grad(B_biotsavart).
        where B_P is the field generated by the plasma currents. 

        Prior to calling this method, set_points(xyz_target) must be called.

        Returns:
            array: (n, 3) array of B(xyz_target).
        """
        dB_bs = self.biotsavart.dB_by_dX()
        dB_ext = self.grad_B_external(self.xyz_target)
        return dB_bs - dB_ext

    def B_external(self, xyz_target):
        """Compute B_external from a vmec equilibria by using the virtual casing principle.

        Args:
            xyz_target (array): (n, 3) array of points NOT on the plasma boundary (s=1).

        Returns:
            array: (n, 3) array of B(xyz_target).
        """

        theta1d = np.linspace(0, 1, self.ntheta, endpoint=False)
        phi1d = np.linspace(0, 1, self.nphi, endpoint=False) # full torus

        # get a "full torus" surface at s
        surf = self.vmec.boundary.copy(quadpoints_phi=phi1d, quadpoints_theta=theta1d)
        normal = surf.normal() # (nphi, ntheta, 3)
        xyz_surf = surf.gamma() # (nphi, ntheta, 3)
        # TODO: use interpolants to get higher accuracy
        n_cross_B = np.cross(normal, self.B_boundary, axis=-1) # (nphi, ntheta, 3)

        debug = False
        if debug:
            Bdotn = np.sum(self.B_boundary*normal, axis=-1)
            print('Bdotn', np.max(np.abs(Bdotn)))

            # sanity check plot
            import matplotlib.pyplot as plt
            ax = plt.figure().add_subplot(projection='3d')
            xyz_surf = xyz_surf.reshape((self.nphi,self.ntheta,3))
            normal = normal.reshape((self.nphi,self.ntheta,3))
            ax.plot_wireframe(xyz_surf[:,:,0], xyz_surf[:,:,1], xyz_surf[:,:,2], alpha=0.4)
            ax.quiver(xyz_surf[:,:,0], xyz_surf[:,:,1], xyz_surf[:,:,2],
                    normal[:,:,0], normal[:,:,1], normal[:,:,2], color='r', length=0.1, normalize=True)
            plt.show()

        dtheta = np.diff(theta1d)[0]
        dphi = np.diff(phi1d)[0]

        # storage
        ntarget = len(xyz_target)
        B_ext = np.zeros((ntarget, 3))

        # integrate
        def B_ext(ii):
            """Compute B_ext at a single target point"""
            rprime = xyz_target[ii] - xyz_surf # (nphi, ntheta, 1)
            norm_rprime_cubed =(np.sqrt(np.sum(rprime**2, axis=-1, keepdims=True))**3) # (nphi, ntheta, 1)
            kernel = rprime / norm_rprime_cubed

            k_cross_n_cross_B = np.cross(kernel, n_cross_B, axis=-1) # (nphi, ntheta, 3)
            integral =  (1 / 4 / np.pi ) * np.sum(k_cross_n_cross_B * dtheta * dphi, axis=(0,1)) # (3,)
            return integral
        
        B_ext = np.array([B_ext(ii) for ii in range(ntarget)])

        return B_ext

    def grad_B_external(self, xyz_target):
        """Compute grad_B_external from a vmec equilibria by using the virtual casing principle.

        Args:
            xyz_target (array): (n, 3) array of points NOT on the plasma boundary (s=1).

        Returns:
            array: (n, 3, 3) array of evaluations of grad_B_external.
        """

        theta1d = np.linspace(0, 1, self.ntheta, endpoint=False)
        phi1d = np.linspace(0, 1, self.nphi, endpoint=False) # full torus

        # get a "full torus" surface at s
        surf = self.vmec.boundary.copy(quadpoints_phi=phi1d, quadpoints_theta=theta1d)
        normal = surf.normal() # (nphi, ntheta, 3)
        xyz_surf = surf.gamma() # (nphi, ntheta, 3)
        n_cross_B = np.cross(normal, self.B_boundary, axis=-1) # (nphi, ntheta, 3)

        dtheta = np.diff(theta1d)[0]
        dphi = np.diff(phi1d)[0]

        # storage
        ntarget = len(xyz_target)
        B_ext = np.zeros((ntarget, 3))

        eye = np.eye(3)
        
        ntarget = len(xyz_target)
        B_ext = np.zeros((3, 3, ntarget))
        for ii in range(ntarget):

            # biot-savart kernel
            rprime = xyz_target[ii] - xyz_surf # (nphi, ntheta, 3)
            norm_rprime_cubed = (np.sqrt(np.sum(rprime**2, axis=-1, keepdims=True))**3) # (nphi, ntheta, 1)
            norm_rprime_fifth = (np.sqrt(np.sum(rprime**2, axis=-1, keepdims=True))**5) # (nphi, ntheta, 1)
            second_term = 3 * rprime / norm_rprime_fifth

            for jj in range(3):

                dkernel_by_djj = eye[jj].reshape((1,1,-1))/norm_rprime_cubed - rprime[:,:,jj][:,:,None] * second_term

                # cross product
                integrand = np.linalg.cross(dkernel_by_djj, n_cross_B, axis=-1) # (nphi, ntheta, 3)

                B_ext[:, jj, ii] =  (1.0 / (4 * np.pi) ) * np.sum(integrand *  dtheta * dphi, axis=(0,1)) # (3,)

        B_ext = B_ext.transpose((2,1,0))  # (n, 3, 3)
        return B_ext

def vmec_virtual_casing(vmec, xyz_target, s=1.0, ntheta=256, nphi=1024):
    """Compute B_external from a vmec equilibria by using the virtual casing principle.

    Args:
        vmec (Vmec): A Vmec object
        xyz_axis (array): (n, 3) array of points NOT on the boundary.
        s (float, optional): radial coordinate on which to perform the VC integral. Defaults to 1.
        ntheta (int, optional): number of theta quadpoints. Defaults to 256.
        nphi (int, optional): number of phi quadpoints. Defaults to 1024.

    Returns:
        array: (n, 3) array of B(xyz_target).
    """
    vmec.run()

    theta1d = np.linspace(0, 1, ntheta, endpoint=False)
    phi1d = np.linspace(0, 1, nphi, endpoint=False) # full torus

    # get a "full torus" surface at s
    surf = vmec.boundary.copy(quadpoints_phi=phi1d, quadpoints_theta=theta1d)

    # data = vmec_compute_geometry(vmec, s=s, theta=np.linspace(0, 2*np.pi, ntheta, endpoint=False),
    #                              phi=np.linspace(0, 2*np.pi, nphi, endpoint=False))
    data = vmec_compute_B(vmec, s=s, theta=np.linspace(0, 2*np.pi, ntheta, endpoint=False),
                                 phi=np.linspace(0, 2*np.pi, nphi, endpoint=False))
    Bx = data.B_X[0].T # (nphi, ntheta)
    By = data.B_Y[0].T
    Bz = data.B_Z[0].T
    B = np.stack([Bx, By, Bz], axis=-1) # (nphi, ntheta, 3)

    normal = surf.normal() # (nphi, ntheta, 3)
    xyz_surf = surf.gamma() # (nphi, ntheta, 3)

    debug = False
    if debug:
        Bdotn = np.sum(B*normal, axis=-1)
        print('Bdotn', np.max(np.abs(Bdotn)))

        # sanity check plot
        import matplotlib.pyplot as plt
        ax = plt.figure().add_subplot(projection='3d')
        xyz_surf = xyz_surf.reshape((nphi,ntheta,3))
        normal = normal.reshape((nphi,ntheta,3))
        ax.plot_wireframe(xyz_surf[:,:,0], xyz_surf[:,:,1], xyz_surf[:,:,2], alpha=0.4)
        ax.quiver(xyz_surf[:,:,0], xyz_surf[:,:,1], xyz_surf[:,:,2],
                normal[:,:,0], normal[:,:,1], normal[:,:,2], color='r', length=0.1, normalize=True)
        plt.show()

    dtheta = np.diff(theta1d)[0]
    dphi = np.diff(phi1d)[0]

    # storage
    nphi = len(xyz_target)
    B_ext = np.zeros((nphi, 3))

    # integrate
    def B_ext_of_phi(ii):
        """Compute B_external(phi) by integrating over a single field period."""
        rprime = xyz_target[ii] - xyz_surf # (ntheta, nzeta, 3)
        norm_rprime_cubed =(np.sqrt(np.sum(rprime**2, axis=-1, keepdims=True))**3) # (nphi, ntheta, 1)
        kernel = rprime / norm_rprime_cubed

        n_cross_B = np.cross(normal, B, axis=-1) # (nphi, ntheta, 3)
        k_cross_n_cross_B = np.cross(kernel, n_cross_B, axis=-1) # (nphi, ntheta, 3)
        integral =  (1 / 4 / np.pi ) * np.sum(k_cross_n_cross_B * dtheta * dphi, axis=(0,1)) # (3,)
        return integral
    
    B_ext = np.array([B_ext_of_phi(ii) for ii in range(nphi)])

    return B_ext


from simsopt.mhd.vmec import Vmec
from simsopt._core.util import Struct
from simsopt.mhd.vmec_diagnostics import vmec_splines
def vmec_compute_B(vs, s, theta, phi, phi_center=0):
    r"""
    Compute many geometric quantities of interest from a vmec configuration.

    Some of the quantities computed by this function refer to
    ``alpha``, a field line label coordinate defined by

    .. math::

        \alpha = \theta_{pest} - \iota (\phi - \phi_{center}).

    Here, :math:`\phi_{center}` is a constant, usually 0, which can be
    set to a nonzero value if desired so the magnetic shear
    contribution to :math:`\nabla\alpha` vanishes at a toroidal angle
    different than 0.  Also, wherever the term ``psi`` appears in
    variable names in this function and the returned arrays, it means
    :math:`\psi =` the toroidal flux divided by :math:`2\pi`, so

    .. math::

        \vec{B} = \nabla\psi\times\nabla\theta_{pest} + \iota\nabla\phi\times\nabla\psi = \nabla\psi\times\nabla\alpha.

    Most of the arrays that are returned by this function have shape
    ``(ns, ntheta, nphi)``, where ``ns`` is the number of flux
    surfaces, ``ntheta`` is the number of grid points in VMEC's
    poloidal angle, and ``nphi`` is the number of grid points in the
    standard toroidal angle. For the arguments ``theta`` and ``phi``,
    you can either provide 1D arrays, in which case a tensor product
    grid is used, or you can provide 3D arrays of shape ``(ns, ntheta,
    nphi)``. In this latter case, the grids are not necessarily
    tensor-product grids.  Note that all angles in this function have
    period :math:`2\pi`, not period 1.

    The output arrays are returned as attributes of the
    returned object. Many intermediate quantities are included, such
    as the Cartesian components of the covariant and contravariant
    basis vectors. Some of the most useful of these output arrays are (all with SI units):

    - ``phi``: The standard toroidal angle :math:`\phi`.
    - ``theta_vmec``: VMEC's poloidal angle :math:`\theta_{vmec}`.
    - ``theta_pest``: The straight-field-line angle :math:`\theta_{pest}` associated with :math:`\phi`.
    - ``modB``: The magnetic field magnitude :math:`|B|`.
    - ``B_sup_theta_vmec``: :math:`\vec{B}\cdot\nabla\theta_{vmec}`.
    - ``B_sup_phi``: :math:`\vec{B}\cdot\nabla\phi`.
    - ``B_cross_grad_B_dot_grad_alpha``: :math:`\vec{B}\times\nabla|B|\cdot\nabla\alpha`.
    - ``B_cross_grad_B_dot_grad_psi``: :math:`\vec{B}\times\nabla|B|\cdot\nabla\psi`.
    - ``B_cross_kappa_dot_grad_alpha``: :math:`\vec{B}\times\vec{\kappa}\cdot\nabla\alpha`,
      where :math:`\vec{\kappa}=\vec{b}\cdot\nabla\vec{b}` is the curvature and :math:`\vec{b}=|B|^{-1}\vec{B}`.
    - ``B_cross_kappa_dot_grad_psi``: :math:`\vec{B}\times\vec{\kappa}\cdot\nabla\psi`.
    - ``grad_alpha_dot_grad_alpha``: :math:`|\nabla\alpha|^2 = \nabla\alpha\cdot\nabla\alpha`.
    - ``grad_alpha_dot_grad_psi``: :math:`\nabla\alpha\cdot\nabla\psi`.
    - ``grad_psi_dot_grad_psi``: :math:`|\nabla\psi|^2 = \nabla\psi\cdot\nabla\psi`.
    - ``L_grad_B``: The scale length of the magnetic field, from Kappel et al, PPCF 66 025018 (2024).
    - ``iota``: The rotational transform :math:`\iota`. This array has shape ``(ns,)``.
    - ``shat``: The magnetic shear :math:`\hat s= (x/q) (d q / d x)` where 
      :math:`x = \mathrm{Aminor_p} \, \sqrt{s}` and :math:`q=1/\iota`. This array has shape ``(ns,)``.

    The following normalized versions of these quantities used in the
    gyrokinetic codes ``stella``, ``gs2``, and ``GX`` are also
    returned: ``bmag``, ``gbdrift``, ``gbdrift0``, ``cvdrift``,
    ``cvdrift0``, ``gds2``, ``gds21``, and ``gds22``, along with
    ``L_reference`` and ``B_reference``.  Instead of ``gradpar``, two
    variants are returned, ``gradpar_theta_pest`` and ``gradpar_phi``,
    corresponding to choosing either :math:`\theta_{pest}` or
    :math:`\phi` as the parallel coordinate.

    The value(s) of ``s`` provided as input need not coincide with the
    full grid or half grid in VMEC, as spline interpolation will be
    used radially.

    The implementation in this routine is similar to the one in the
    gyrokinetic code ``stella``.

    Example usage::

        import numpy as np
        from simsopt.mhd import Vmec, vmec_compute_geometry

        v = Vmec("wout_li383_1.4m.nc")
        s = 1
        theta = np.linspace(0, 2 * np.pi, 50)
        phi = np.linspace(0, 2 * np.pi / 3, 60)
        data = vmec_compute_geometry(v, s, theta, phi)
        print(data.grad_s_dot_grad_s)

    Args:
        vs: Either an instance of :obj:`simsopt.mhd.vmec.Vmec`
          or the structure returned by :func:`vmec_splines`.
        s: Values of normalized toroidal flux on which to construct the field lines.
          You can give a single number, or a list or numpy array.
        theta: Values of vmec's poloidal angle. You can provide a float, a 1d array of size
          ``(ntheta,)``, or a 3d array of size ``(ns, ntheta, nphi)``.
        phi: Values of the standard toroidal angle. You can provide a float, a 1d array of size
          ``(nphi,)`` or a 3d array of size ``(ns, ntheta, nphi)``.
        phi_center: :math:`\phi_{center}`, an optional shift to the toroidal angle
          in the definition of :math:`\alpha`.
    """
    # If given a Vmec object, convert it to vmec_splines:
    if isinstance(vs, Vmec):
        vs = vmec_splines(vs)
    if not vs.stellsym:
        raise NotImplementedError("vmec_compute_geometry() does not yet support non-stellarator-symmetric configurations.")

    # Make sure s is an array:
    try:
        ns = len(s)
    except:
        s = [s]
    s = np.array(s)
    ns = len(s)

    # Handle theta
    try:
        ntheta = len(theta)
    except:
        theta = [theta]
    theta_vmec = np.array(theta)
    if theta_vmec.ndim == 1:
        ntheta = len(theta_vmec)
    elif theta_vmec.ndim == 3:
        ntheta = theta_vmec.shape[1]
    else:
        raise ValueError("theta argument must be a float, 1d array, or 3d array.")

    # Handle phi
    try:
        nphi = len(phi)
    except:
        phi = [phi]
    phi = np.array(phi)
    if phi.ndim == 1:
        nphi = len(phi)
    elif phi.ndim == 3:
        nphi = phi.shape[2]
    else:
        raise ValueError("phi argument must be a float, 1d array, or 3d array.")

    # If theta and phi are not already 3D, make them 3D:
    if theta_vmec.ndim == 1:
        theta_vmec = np.kron(np.ones((ns, 1, nphi)), theta_vmec.reshape(1, ntheta, 1))
    if phi.ndim == 1:
        phi = np.kron(np.ones((ns, ntheta, 1)), phi.reshape(1, 1, nphi))

    # Shorthand:
    mnmax = vs.mnmax
    xm = vs.xm
    xn = vs.xn
    mnmax_nyq = vs.mnmax_nyq
    xm_nyq = vs.xm_nyq
    xn_nyq = vs.xn_nyq

    # Now that we have an s grid, evaluate everything on that grid:
    # d_pressure_d_s = vs.d_pressure_d_s(s)
    iota = vs.iota(s)
    # d_iota_d_s = vs.d_iota_d_s(s)
    # shat = (r/q)(dq/dr) where r = a sqrt(s)
    #      = - (r/iota) (d iota / d r) = -2 (s/iota) (d iota / d s)
    # shat = (-2 * s / iota) * d_iota_d_s

    rmnc = np.zeros((ns, mnmax))
    zmns = np.zeros((ns, mnmax))
    lmns = np.zeros((ns, mnmax))
    d_rmnc_d_s = np.zeros((ns, mnmax))
    d_zmns_d_s = np.zeros((ns, mnmax))
    d_lmns_d_s = np.zeros((ns, mnmax))
    for jmn in range(mnmax):
        rmnc[:, jmn] = vs.rmnc[jmn](s)
        zmns[:, jmn] = vs.zmns[jmn](s)
        lmns[:, jmn] = vs.lmns[jmn](s)
        d_rmnc_d_s[:, jmn] = vs.d_rmnc_d_s[jmn](s)
        d_zmns_d_s[:, jmn] = vs.d_zmns_d_s[jmn](s)
        d_lmns_d_s[:, jmn] = vs.d_lmns_d_s[jmn](s)

    gmnc = np.zeros((ns, mnmax_nyq))
    bmnc = np.zeros((ns, mnmax_nyq))
    d_bmnc_d_s = np.zeros((ns, mnmax_nyq))
    bsupumnc = np.zeros((ns, mnmax_nyq))
    bsupvmnc = np.zeros((ns, mnmax_nyq))
    bsubsmns = np.zeros((ns, mnmax_nyq))
    bsubumnc = np.zeros((ns, mnmax_nyq))
    bsubvmnc = np.zeros((ns, mnmax_nyq))
    d_bsupumnc_d_s = np.zeros((ns, mnmax_nyq))
    d_bsupvmnc_d_s = np.zeros((ns, mnmax_nyq))
    for jmn in range(mnmax_nyq):
        gmnc[:, jmn] = vs.gmnc[jmn](s)
        bmnc[:, jmn] = vs.bmnc[jmn](s)
        d_bmnc_d_s[:, jmn] = vs.d_bmnc_d_s[jmn](s)
        bsupumnc[:, jmn] = vs.bsupumnc[jmn](s)
        bsupvmnc[:, jmn] = vs.bsupvmnc[jmn](s)
        bsubsmns[:, jmn] = vs.bsubsmns[jmn](s)
        bsubumnc[:, jmn] = vs.bsubumnc[jmn](s)
        bsubvmnc[:, jmn] = vs.bsubvmnc[jmn](s)
        d_bsupumnc_d_s[:, jmn] = vs.d_bsupumnc_d_s[jmn](s)
        d_bsupvmnc_d_s[:, jmn] = vs.d_bsupvmnc_d_s[jmn](s)

    # Now that we know theta_vmec, compute all the geometric quantities
    angle = xm[:, None, None, None] * theta_vmec[None, :, :, :] - xn[:, None, None, None] * phi[None, :, :, :]
    cosangle = np.cos(angle)
    sinangle = np.sin(angle)
    mcosangle = xm[:, None, None, None] * cosangle
    ncosangle = xn[:, None, None, None] * cosangle
    # mncosangle = xm[:, None, None, None] * xn[:, None, None, None] * cosangle
    # m2cosangle = xm[:, None, None, None]**2 * cosangle
    # n2cosangle = xn[:, None, None, None]**2 * cosangle
    msinangle = xm[:, None, None, None] * sinangle
    nsinangle = xn[:, None, None, None] * sinangle
    # mnsinangle = xm[:, None, None, None] * xn[:, None, None, None] * sinangle
    # m2sinangle = xm[:, None, None, None]**2 * sinangle
    # n2sinangle = xn[:, None, None, None]**2 * sinangle
    # Order of indices in cosangle and sinangle: mn, s, theta, phi
    # Order of indices in rmnc, bmnc, etc: s, mn
    R = np.einsum('ij,jikl->ikl', rmnc, cosangle)
    # d_R_d_s = np.einsum('ij,jikl->ikl', d_rmnc_d_s, cosangle)
    d_R_d_theta_vmec = np.einsum('ij,jikl->ikl', -rmnc, msinangle)
    d_R_d_phi = np.einsum('ij,jikl->ikl', rmnc, nsinangle)
    # d2_R_d_phi2 = np.einsum('ij,jikl->ikl', -rmnc, n2cosangle)
    # d2_R_d_theta_vmec2 = np.einsum('ij,jikl->ikl', -rmnc, m2cosangle)
    # d2_R_d_theta_vmec_d_phi = np.einsum('ij,jikl->ikl', rmnc, mncosangle)
    # d2_R_d_s_d_theta_vmec = np.einsum('ij,jikl->ikl', -d_rmnc_d_s, msinangle)
    # d2_R_d_s_d_phi = np.einsum('ij,jikl->ikl', d_rmnc_d_s, nsinangle)

    # Z = np.einsum('ij,jikl->ikl', zmns, sinangle)
    # d_Z_d_s = np.einsum('ij,jikl->ikl', d_zmns_d_s, sinangle)
    d_Z_d_theta_vmec = np.einsum('ij,jikl->ikl', zmns, mcosangle)
    d_Z_d_phi = np.einsum('ij,jikl->ikl', -zmns, ncosangle)
    # d2_Z_d_theta_vmec2 = np.einsum('ij,jikl->ikl', -zmns, m2sinangle)
    # d2_Z_d_phi2 = np.einsum('ij,jikl->ikl', -zmns, n2sinangle)
    # d2_Z_d_theta_vmec_d_phi = np.einsum('ij,jikl->ikl', zmns, mnsinangle)
    # d2_Z_d_s_d_theta_vmec = np.einsum('ij,jikl->ikl', d_zmns_d_s, mcosangle)
    # d2_Z_d_s_d_phi = np.einsum('ij,jikl->ikl', -d_zmns_d_s, ncosangle)

    # lambd = np.einsum('ij,jikl->ikl', lmns, sinangle)
    # d_lambda_d_s = np.einsum('ij,jikl->ikl', d_lmns_d_s, sinangle)
    d_lambda_d_theta_vmec = np.einsum('ij,jikl->ikl', lmns, mcosangle)
    d_lambda_d_phi = np.einsum('ij,jikl->ikl', -lmns, ncosangle)
    # theta_pest = theta_vmec + lambd

    # Now handle the Nyquist quantities:
    angle = xm_nyq[:, None, None, None] * theta_vmec[None, :, :, :] - xn_nyq[:, None, None, None] * phi[None, :, :, :]
    cosangle = np.cos(angle)
    sinangle = np.sin(angle)
    mcosangle = xm_nyq[:, None, None, None] * cosangle
    ncosangle = xn_nyq[:, None, None, None] * cosangle
    msinangle = xm_nyq[:, None, None, None] * sinangle
    nsinangle = xn_nyq[:, None, None, None] * sinangle

    sqrt_g_vmec = np.einsum('ij,jikl->ikl', gmnc, cosangle)
    # modB = np.einsum('ij,jikl->ikl', bmnc, cosangle)
    # d_B_d_s = np.einsum('ij,jikl->ikl', d_bmnc_d_s, cosangle)
    # d_B_d_theta_vmec = np.einsum('ij,jikl->ikl', -bmnc, msinangle)
    # d_B_d_phi = np.einsum('ij,jikl->ikl', bmnc, nsinangle)

    # B_sup_theta_vmec = np.einsum('ij,jikl->ikl', bsupumnc, cosangle)
    # B_sup_phi = np.einsum('ij,jikl->ikl', bsupvmnc, cosangle)
    # B_sub_s = np.einsum('ij,jikl->ikl', bsubsmns, sinangle)
    # B_sub_theta_vmec = np.einsum('ij,jikl->ikl', bsubumnc, cosangle)
    # B_sub_phi = np.einsum('ij,jikl->ikl', bsubvmnc, cosangle)
    # B_sup_theta_pest = iota[:, None, None] * B_sup_phi
    # d_B_sup_phi_d_theta_vmec = np.einsum('ij,jikl->ikl', -bsupvmnc, msinangle)
    # d_B_sup_phi_d_phi = np.einsum('ij,jikl->ikl', bsupvmnc, nsinangle)
    # d_B_sup_theta_vmec_d_theta_vmec = np.einsum('ij,jikl->ikl', -bsupumnc, msinangle)
    # d_B_sup_theta_vmec_d_phi = np.einsum('ij,jikl->ikl', bsupumnc, nsinangle)
    # d_B_sup_theta_vmec_d_s = np.einsum('ij,jikl->ikl', d_bsupumnc_d_s, cosangle)
    # d_B_sup_phi_d_s = np.einsum('ij,jikl->ikl', d_bsupvmnc_d_s, cosangle)

    # sqrt_g_vmec_alt = R * (d_Z_d_s * d_R_d_theta_vmec - d_R_d_s * d_Z_d_theta_vmec)

    # Note the minus sign. psi in the straight-field-line relation seems to have opposite sign to vmec's phi array.
    edge_toroidal_flux_over_2pi = -vs.phiedge / (2 * np.pi)

    # *********************************************************************
    # Using R(theta,phi) and Z(theta,phi), compute the Cartesian
    # components of the gradient basis vectors using the dual relations:
    # *********************************************************************
    sinphi = np.sin(phi)
    cosphi = np.cos(phi)
    # X = R * cosphi
    d_X_d_theta_vmec = d_R_d_theta_vmec * cosphi
    d_X_d_phi = d_R_d_phi * cosphi - R * sinphi
    # d_X_d_s = d_R_d_s * cosphi
    # Y = R * sinphi
    d_Y_d_theta_vmec = d_R_d_theta_vmec * sinphi
    d_Y_d_phi = d_R_d_phi * sinphi + R * cosphi
    # d_Y_d_s = d_R_d_s * sinphi


    # *********************************************************************
    # Compute the Cartesian components of other quantities we need:
    # *********************************************************************


    B_X = edge_toroidal_flux_over_2pi * ((1 + d_lambda_d_theta_vmec) * d_X_d_phi + (iota[:, None, None] - d_lambda_d_phi) * d_X_d_theta_vmec) / sqrt_g_vmec
    B_Y = edge_toroidal_flux_over_2pi * ((1 + d_lambda_d_theta_vmec) * d_Y_d_phi + (iota[:, None, None] - d_lambda_d_phi) * d_Y_d_theta_vmec) / sqrt_g_vmec
    B_Z = edge_toroidal_flux_over_2pi * ((1 + d_lambda_d_theta_vmec) * d_Z_d_phi + (iota[:, None, None] - d_lambda_d_phi) * d_Z_d_theta_vmec) / sqrt_g_vmec


    # Package results into a structure to return:
    results = Struct()
    variables = ['B_X', 'B_Y', 'B_Z']
    for v in variables:
        results.__setattr__(v, eval(v))

    return results
